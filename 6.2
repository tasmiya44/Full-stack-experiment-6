const mongoose = require('mongoose');

const RefreshTokenSchema = new mongoose.Schema({
  token: { type: String, required: true },
  createdAt: { type: Date, default: Date.now },
  expiresAt: { type: Date, required: true }
});

const UserSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true, lowercase: true, trim: true },
  passwordHash: { type: String, required: true },
  name: { type: String },
  balance: { type: Number, default: 0 }, // banking field example
  role: { type: String, enum: ['user','admin'], default: 'user' },
  refreshTokens: [RefreshTokenSchema] // store refresh tokens for rotation/revoke
}, { timestamps: true });

module.exports = mongoose.model('User', UserSchema);
const jwt = require('jsonwebtoken');

function signAccessToken(payload) {
  return jwt.sign(payload, process.env.JWT_ACCESS_SECRET, { expiresIn: process.env.ACCESS_TOKEN_EXPIRES || '15m' });
}

function signRefreshToken(payload) {
  return jwt.sign(payload, process.env.JWT_REFRESH_SECRET, { expiresIn: process.env.REFRESH_TOKEN_EXPIRES || '7d' });
}

function verifyAccessToken(token) {
  return jwt.verify(token, process.env.JWT_ACCESS_SECRET);
}

function verifyRefreshToken(token) {
  return jwt.verify(token, process.env.JWT_REFRESH_SECRET);
}

module.exports = { signAccessToken, signRefreshToken, verifyAccessToken, verifyRefreshToken };
const express = require('express');
const bcrypt = require('bcryptjs');
const { signAccessToken, signRefreshToken, verifyRefreshToken } = require('../utils/jwt');
const User = require('../models/User');

const router = express.Router();

// Register
router.post('/register', async (req, res) => {
  const { email, password, name } = req.body;
  if (!email || !password) return res.status(400).json({ message: 'Email and password required' });

  const existing = await User.findOne({ email });
  if (existing) return res.status(409).json({ message: 'Email already in use' });

  const salt = await bcrypt.genSalt(12);
  const passwordHash = await bcrypt.hash(password, salt);

  const user = await User.create({ email, passwordHash, name });
  // Do NOT return passwordHash
  return res.status(201).json({ id: user._id, email: user.email, name: user.name });
});

// Login -> issue access + refresh
router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  if (!email || !password) return res.status(400).json({ message: 'Email and password required' });

  const user = await User.findOne({ email });
  if (!user) return res.status(401).json({ message: 'Invalid credentials' });

  const valid = await bcrypt.compare(password, user.passwordHash);
  if (!valid) return res.status(401).json({ message: 'Invalid credentials' });

  const payload = { sub: user._id.toString(), role: user.role };

  const accessToken = signAccessToken(payload);
  const refreshToken = signRefreshToken(payload);

  // store refresh token server-side for revocation / rotation
  const expiresAt = new Date(Date.now() + 7*24*60*60*1000); // match REFRESH_TOKEN_EXPIRES
  user.refreshTokens.push({ token: refreshToken, expiresAt });
  await user.save();

  // Send access token in response body (for API clients using Authorization header)
  // AND set HttpOnly secure cookie for browsers (defense-in-depth)
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    sameSite: 'lax', // consider 'strict' where possible
    secure: process.env.NODE_ENV === 'production',
    maxAge: 7*24*60*60*1000,
    domain: process.env.COOKIE_DOMAIN
  });

  return res.json({ accessToken, expiresIn: process.env.ACCESS_TOKEN_EXPIRES || '15m' });
});

// Refresh endpoint: rotate refresh token
router.post('/refresh', async (req, res) => {
  // prefer reading refresh token from cookie for browser clients
  const token = req.cookies?.refreshToken || req.body.refreshToken;
  if (!token) return res.status(401).json({ message: 'No refresh token' });

  let payload;
  try { payload = verifyRefreshToken(token); }
  catch (err) { return res.status(401).json({ message: 'Invalid refresh token' }); }

  const user = await User.findById(payload.sub);
  if (!user) return res.status(401).json({ message: 'User not found' });

  // check token exists server-side
  const stored = user.refreshTokens.find(rt => rt.token === token);
  if (!stored) {
    // possible reuse â€” revoke all tokens and force re-login
    user.refreshTokens = [];
    await user.save();
    return res.status(401).json({ message: 'Refresh token revoked' });
  }

  // rotate: remove used RT and issue new RT + Access token
  user.refreshTokens = user.refreshTokens.filter(rt => rt.token !== token);

  const newAccess = signAccessToken({ sub: user._id.toString(), role: user.role });
  const newRefresh = signRefreshToken({ sub: user._id.toString(), role: user.role });
  user.refreshTokens.push({ token: newRefresh, expiresAt: new Date(Date.now() + 7*24*60*60*1000) });
  await user.save();

  res.cookie('refreshToken', newRefresh, {
    httpOnly: true,
    sameSite: 'lax',
    secure: process.env.NODE_ENV === 'production',
    maxAge: 7*24*60*60*1000,
    domain: process.env.COOKIE_DOMAIN
  });

  return res.json({ accessToken: newAccess, expiresIn: process.env.ACCESS_TOKEN_EXPIRES || '15m' });
});

// Logout: revoke refresh token(s)
router.post('/logout', async (req, res) => {
  const token = req.cookies?.refreshToken || req.body.refreshToken;
  if (token && req.user) {
    // if you have req.user from middleware you can remove specific token
    const user = await User.findById(req.user.sub);
    user.refreshTokens = user.refreshTokens.filter(rt => rt.token !== token);
    await user.save();
  }
  res.clearCookie('refreshToken', { domain: process.env.COOKIE_DOMAIN });
  res.status(200).json({ message: 'Logged out' });
});

module.exports = router;
const jwt = require('jsonwebtoken');

// for endpoints that require an access token
function requireAuth(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith('Bearer ')) return res.status(401).json({ message: 'Missing auth token' });

  const token = auth.split(' ')[1];
  try {
    const payload = jwt.verify(token, process.env.JWT_ACCESS_SECRET);
    req.user = payload; // payload.sub is user id
    return next();
  } catch (err) {
    return res.status(401).json({ message: 'Invalid or expired token' });
  }
}

// role check
function requireRole(role) {
  return (req, res, next) => {
    if (!req.user) return res.status(401).json({ message: 'Unauthenticated' });
    if (req.user.role !== role) return res.status(403).json({ message: 'Forbidden' });
    next();
  };
}

module.exports = { requireAuth, requireRole };
const express = require('express');
const User = require('../models/User');
const { requireAuth } = require('../middleware/auth');

const router = express.Router();

// get balance
router.get('/me', requireAuth, async (req, res) => {
  const user = await User.findById(req.user.sub).select('-passwordHash -refreshTokens');
  if (!user) return res.status(404).json({ message: 'User not found' });
  res.json({ id: user._id, email: user.email, name: user.name, balance: user.balance });
});

// transfer funds (example)
router.post('/transfer', requireAuth, async (req, res) => {
  const { toEmail, amount } = req.body;
  if (!toEmail || !amount || amount <= 0) return res.status(400).json({ message: 'Invalid transfer' });

  const from = await User.findById(req.user.sub);
  if (from.balance < amount) return res.status(400).json({ message: 'Insufficient funds' });

  const to = await User.findOne({ email: toEmail });
  if (!to) return res.status(404).json({ message: 'Recipient not found' });

  // In production: wrap in DB transaction / two-phase commit / ledger
  from.balance -= amount;
  to.balance += amount;

  await from.save();
  await to.save();

  // record transaction in transactions collection (omitted for brevity)
  res.json({ message: 'Transfer complete', balance: from.balance });
});

module.exports = router;
require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cookieParser = require('cookie-parser');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

const authRoutes = require('./routes/auth');
const bankRoutes = require('./routes/banking');

const app = express();
app.use(helmet());
app.use(express.json());
app.use(cookieParser());

// Basic rate limiting
const limiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 100 // tune per endpoint
});
app.use(limiter);

// routes
app.use('/api/auth', authRoutes);
app.use('/api/bank', bankRoutes);

// global error handling (example)
app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).json({ message: 'Internal server error' });
});

async function start() {
  await mongoose.connect(process.env.MONGO_URI);
  const port = process.env.PORT || 4000;
  app.listen(port, () => console.log(`Listening ${port}`));
}

start().catch(err => {
  console.error('Failed to start', err);
});
// login.js (React)
async function login(email, password, setAccessToken) {
  const res = await fetch('/api/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
    credentials: 'include' // important to accept cookies
  });
  const data = await res.json();
  if (res.ok) {
    // data.accessToken -> store in memory (state)
    setAccessToken(data.accessToken);
  } else {
    throw new Error(data.message || 'Login failed');
  }
}
